///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

xFactor := function(f)
  return Min([IntegerRing() | Exponents(t)[1] : t in Terms(f) | t ne 0]);
end function;

yFactor := function(f)
  return Min([IntegerRing() | Exponents(t)[2] : t in Terms(f) | t ne 0]);
end function;

// SquarefreePart not available for local polynomial rings.
intrinsic SquarefreePart(f::RngMPolLocElt) -> RngMPolLocElt
{ Return the squarefree part of f, which is the largest (normalized)
  divisor g of f which is squarefree. }
  P := Parent(f); Q := PolynomialRing(CoefficientRing(P), Rank(P));
  return P!SquarefreePart(Q!f);
end intrinsic;

// SquarefreeFactorization not available for local polynomial rings.
intrinsic SquarefreeFactorization(f::RngMPolLocElt) -> SeqEnum
{ Factorize into squarefree polynomials the polynomial f. }
  P := Parent(f); Q := PolynomialRing(CoefficientRing(P), Rank(P));
  return [ <P!g[1], g[2]> : g in SquarefreeFactorization(Q!f) ];
end intrinsic;

// Hack to return 0 when 0 * Infinity() is computed.
MyProd := function(a, b)
  if a eq 0 or b eq 0 then return 0;
  else return a * b; end if;
end function;

// Counter clockwise turn.
CcwTurn := function(p1, p2, p3)
  return (MyProd(p2[1] - p1[1], p3[2] - p1[2]) -
          MyProd(p2[2] - p1[2], p3[1] - p1[1])) le 0;
end function;

// Magma's NewtonPolygon function does not work in our case.
intrinsic NewtonPolygon(f::RngMPolLocElt) -> SeqEnum
{ The newton polygon for the bivariate polynomial f. }
require Rank(Parent(f)) eq 2: "Argument must be a bivariate polynomial";
  NP := [];
  for p in Sort([Exponents(m) : m in Monomials(f)]) cat [[Infinity(), 0]] do
    while #NP ge 2 and CcwTurn(NP[#NP - 1], NP[#NP], p) do
      Prune(~NP);
    end while; NP cat:= [p];
  end for; Prune(~NP); return NP;
end intrinsic;

NewtonSide := procedure(p, q, ~f, ~S)
  g := Gcd(p[2] - q[2], q[1] - p[1]);
  n := (p[2] - q[2]) div g;
  m := (q[1] - p[1]) div g;
  k := (p[2] * q[1] - p[1] * q[2]) div g;

  // Select which exponents are on the side generated by p & q.
  Q<X, Y> := PolynomialRing(IntegerRing(), 2);
  side := n * X + m * Y - k;
  C, M := CoefficientsAndMonomials(f);
  onSide := [C[i] * M[i] : i in [1..#M] |
    Evaluate(side, <Exponents(M[i])[1], Exponents(M[i])[2]>) eq 0];

  // Construct the equation associated with the pq side.
  P<Z> := PolynomialRing(CoefficientRing(Parent(f)));
  h := Evaluate(&+onSide, <1, Z>);
  E, _ := Support(h); C := Coefficients(h);
  beta0 := Reverse(Sort([Exponents(m) : m in onSide]))[1][2];
  S cat:= [<n, m, &+[C[e + 1] * Z^((e - beta0) div n) : e in E]>];
end procedure;

intrinsic NewtonSides(f::RngMPolLocElt, NP::SeqEnum) -> SeqEnum
{ Returns the sides of the Newton polygon. }
require Rank(Parent(f)) eq 2: "Argument must be a bivariate polynomial";
  S := [];
  for i in [1..#NP-1] do
    NewtonSide(NP[i], NP[i+1], ~f, ~S);
  end for; return S;
end intrinsic;

// It seems there is a bug when composing Puiseux series in Magma.
MyComposition := function(s1, n)
  P := Parent(s1); x := P.1; C, a, b := Coefficients(s1);
  return &+([P!0] cat [C[i] * x^((a + i - 1) / (n * b)) : i in [1..#C]]);
end function;

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

forward NewtonPuiseuxAlgorithmLoop;

intrinsic NewtonPuiseuxAlgorithm(f::RngMPolLocElt : Terms := -1,
                                                    Polynomial := false) -> [ ]
{ Computes the Puiseux expansion of any bivariate polynomial }
require Rank(Parent(f)) eq 2: "Argument must be a bivariate polynomial";
  // If Nf start on the right of the x-axis, we have an x-factor.
  yBranch := (xFactor(f) gt 0) select [* <Parent(f).1,
    [<xFactor(f), 1>], Parent(f).1> *] else [* *];

  P<x, y> := LocalPolynomialRing(AlgebraicClosure(
    CoefficientRing(Parent(f))), 2, "lglex");
  S := yBranch cat SequenceToList(NewtonPuiseuxAlgorithmLoop(P!SquarefreePart(f),
    [<P!g[1], g[2], 1> : g in SquarefreeFactorization(f)], Terms - 1));
  if not Polynomial then return [* <s[1], s[2][1][1]> : s in S *];
  else return [* <s[1], s[2][1][1], s[3]> : s in S *]; end if;
end intrinsic;

intrinsic NewtonPuiseuxAlgorithm(L::[RngMPolLocElt] : Terms := -1,
                                                      Polynomial := false) -> [ ]
{ Computes the Puiseux expansion for the product of all the elements of L }
require #L gt 0: "Argument must be a non-empty list";
require &and[Rank(Parent(f)) eq 2 : f in L]:
  "Elements of L must be bivariate polynomials";
  f := &*L;
  P<x, y> := LocalPolynomialRing(AlgebraicClosure(
    CoefficientRing(Parent(f))), 2, "lglex");
  // If Nf start on the right of the x-axis, we have an x-factor.
  yBranch := (xFactor(f) gt 0) select [* <Parent(f).1,
    [<xFactor(L[i]), i> : i in [1..#L] | xFactor(L[i]) ne 0], x> *] else [* *];

  sqFreePart := P!SquarefreePart(f); sqFreeFact := [];
  for i in [1..#L] do
  sqFreeFact cat:= [<P!g[1], g[2], i>: g in SquarefreeFactorization(L[i]) |
    Evaluate(L[i], <0, 0>) eq 0];
  end for;
  S := yBranch cat SequenceToList(NewtonPuiseuxAlgorithmLoop(sqFreePart,
    sqFreeFact, Terms - 1));

  // Return the polynomial residue if requested.
  if not Polynomial then return [* <s[1], s[2]> : s in S *];
  else return S; end if;
end intrinsic;

NewtonPuiseuxAlgorithmLoop := function(f, L, terms)
  Q<x> := PuiseuxSeriesRing(CoefficientRing(Parent(f)));
  x0 := Parent(f).1; y0 := Parent(f).2;
  // Step (i.a): Select only those factors containing the 0 branch.
  S := yFactor(f) gt 0 select [<Q!0, [<g[2], g[3]> : g in L
    | yFactor(g[1]) ne 0], y0>] else [];
  // Step (i.b): For each side...
  for F in NewtonSides(f, NewtonPolygon(f)) do
    n := F[1]; m := F[2]; P := F[3];
    // Apply the change of variables (1).
    C := Reverse(Coefficients(n eq 1 select f else Evaluate(f, 1, x0^n), 2));
    CL := [<Reverse(Coefficients(n eq 1 select g[1] else
      Evaluate(g[1], 1, x0^n), 2)), g[2], g[3]> : g in L];
    // For each root...
    for a in [<Root(a[1], n), a[2]> : a in Roots(P)] do
      // Apply the change of variables (2) & get the sub-solution recursively.
      ff := [i gt 1 select C[i] + Self(i-1) * x0^m * (a[1] + y0) else C[1] :
        i in [1..#C]][#C];
      LL := [<[i gt 1 select Cj[1][i] + Self(i-1) * x0^m * (a[1] + y0) else
        Cj[1][1] : i in [1..#Cj[1]]][#Cj[1]], Cj[2], Cj[3]> : Cj in CL];
      // Select only those factors that contain the current branch.
      LL := [g : g in LL | NewtonPolygon(g[1])[1][2] ne 0];
      // If the mult. of a is greater than 1 continue.
      R := (a[2] ne 1 and terms lt -1) or terms gt 0 select
        NewtonPuiseuxAlgorithmLoop(ff, LL, terms - 1) else
          [<Q!0, [<g[2], g[3]> : g in LL], ff>];
      // Undo the change of variables.
      S cat:= [<x^(m/n) * (a[1] + MyComposition(s[1], n)), s[2], s[3]> : s in R];
    end for;
  end for;
  return S;
end function;

forward NewtonPuiseuxAlgorithmReducedLoop;

intrinsic NewtonPuiseuxAlgorithmReduced(f::RngMPolLocElt : Terms := -1,
                                        Polynomial := false) -> [ ]
{ Computes the Puiseux expansion of a reduced bivariate polynomial }
require Rank(Parent(f)) eq 2: "Argument must be a bivariate polynomial";
  P := LocalPolynomialRing(AlgebraicClosure(
    CoefficientRing(Parent(f))), 2, "lglex");
  // If Nf start on the right of the x-axis, we have an x-factor.
  yBranch := (xFactor(f) gt 0) select [<Parent(f).1, P.1>] else [];

  S := yBranch cat NewtonPuiseuxAlgorithmReducedLoop(
    P!SquarefreePart(f), Terms - 1);
  if Polynomial then return S; else return [s[1] : s in S]; end if;
end intrinsic;

intrinsic NewtonPuiseuxAlgorithmExpandReduced(s::RngSerPuisElt, f::RngMPolLocElt
                                             : Terms := 1, Polynomial := false) -> [ ]
{ Expands the Puiseux expansion s of a reduced bivariate polynomial }
require Rank(Parent(f)) eq 2: "Argument f must be a bivariate polynomial";
  n := ExponentDenominator(s); x := Parent(s).1;
  m := s eq 0 select 0 else Degree(s);

  S := Terms gt 0 select NewtonPuiseuxAlgorithmReducedLoop(f, Terms - 1)
       else [<PuiseuxSeriesRing(CoefficientRing(Parent(f)))!0, f>];
  P<x> := PuiseuxSeriesRing(CoefficientRing(Parent(s)));
  if Polynomial then return [<s + x^m * MyComposition(si[1], n), si[2]> : si in S];
  else return [s + x^m * MyComposition(si[1], n): si in S]; end if;
end intrinsic;

intrinsic NewtonPuiseuxAlgorithmExpandReduced(x::RngMPolLocElt, f::RngMPolLocElt
                                              : Terms := 1, Polynomial := false) -> [ ]
{ Expands the Puiseux expansion s of a reduced bivariate polynomial }
require Rank(Parent(f)) eq 2: "Argument f must be a bivariate polynomial";
  if Polynomial then return [<x, x>]; else return [x]; end if;
end intrinsic;

NewtonPuiseuxAlgorithmReducedLoop := function(f, terms)
  Q<x> := PuiseuxSeriesRing(CoefficientRing(Parent(f)));
  x0 := Parent(f).1; y0 := Parent(f).2;
  // Step (i.a): Select only those factors containing the 0 branch.
  S := yFactor(f) gt 0 select [<Q!0, y0>] else [];
  // Step (i.b): For each side...
  for F in NewtonSides(f, NewtonPolygon(f)) do
    n := F[1]; m := F[2]; P := F[3];
    // Apply the change of variables (1).
    C := Reverse(Coefficients(n eq 1 select f else Evaluate(f, 1, x0^n), 2));
    // For each root...
    for a in [<Root(a[1], n), a[2]> : a in Roots(P)] do
      // Apply the change of variables (2) & get the sub-solution recursively.
      g := [i gt 1 select C[i] + Self(i-1) * x0^m * (a[1] + y0) else C[1]
         : i in [1..#C]][#C];
      R := (a[2] ne 1 and terms lt -1) or terms gt 0 select
        NewtonPuiseuxAlgorithmReducedLoop(g, terms - 1) else [<Q!0, g>];
      // Undo the change of variables.
      S cat:= [<x^(m/n) * (a[1] + MyComposition(s[1], n)), s[2]> : s in R];
    end for;
  end for; return S;
end function;
